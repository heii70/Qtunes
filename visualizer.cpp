#include <iostream>
#include <fstream>
#include <cstdlib>
#include <assert.h>
#include "visualizer.h"
#include <QOpenGLFunctions>
#include <glu.h>
#include <QtWidgets>
#include <QGLWidget>
#include <QMediaPlayer>
using namespace std;

// VisualizerWidget::VisualizerWidget()
//
// VisualizerWidget constructor. Sets the dimensions of the widget
// and sets up two QTimers, m_painter and m_newRandNum
//
VisualizerWidget::VisualizerWidget(){
    //Scale the visualizer to the same dimensions as the coverflow
    m_width = 3;
    m_height = 1;
    m_scale = 250;
    setMinimumSize(m_width*m_scale,m_height*m_scale);
    resize(m_width*m_scale,m_height*m_scale);
    setMaximumSize(m_width*m_scale,m_height*m_scale);
    setSizeIncrement(m_width,m_height);

    //Add a qtimer that paints the bars of the visualizer
    m_painter = new QTimer(this);
    m_painter->start(10);
    connect(m_painter, SIGNAL(timeout()), this, SLOT(update()));

    //Add a qtimer that generates new random values for the bars
    m_newRandNum = new QTimer(this);
    m_newRandNum->setInterval(400);
    connect(m_newRandNum, SIGNAL(timeout()), this, SLOT(s_randomizer()));
}

// VisualizerWidget::~VisualizerWidget()
//
// VisualizerWidget destructor.
//
VisualizerWidget::~VisualizerWidget(){
}

// VisualizerWidget::initializeGL()
//
// Specifies clear values for the color buffer, and smooths the lines out.
//
void VisualizerWidget::initializeGL(){
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glEnable(GL_LINE_SMOOTH);
}

// VisualizerWidget::resizeGL(int w, int h)
//
// Resizes the widget, sets the dimensions, and specifies the matrix mode.
//
void VisualizerWidget::resizeGL(int w, int h){
    resize(w,h);
    glMatrixMode(GL_PROJECTION);

    //Sets the visualizer to orthographic view (2D projection, no perspective)
    //The dimensions have been adjusted to allow for a little bit of room between the bars and the edge of the widget
    glOrtho(0.5, 11.6, -0.1, 1.1, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

// VisualizerWidget::s_toggle(QMediaPlayer::State state)
//
// Called from MainWindow.cpp. Checks the current state of the media player
// and activates the random number timer only when a song is playing.
// Otherwise, it will stop
void VisualizerWidget::s_toggle(QMediaPlayer::State state){
    //If a song is currently playing, generate new random numbers
    if(state == QMediaPlayer::PlayingState)
        m_newRandNum->start();

    //Song is either stopped or paused, so stop the random number timer
    else
        m_newRandNum->stop();
}

// VisualizerWidget::s_changeSpeed(signed int s)
//
// Called from MainWindow.cpp. Sets the interval of m_newRandNum depending
// on the playback speed selected. Signed ints are used instead of floats
// because floats lack precision.
//
void VisualizerWidget::s_changeSpeed(signed int s){
    switch(s){
        case -2:
            m_newRandNum->setInterval(600);
            return;
        case -1:
            m_newRandNum->setInterval(500);
            return;
        case 0:
            m_newRandNum->setInterval(400);
            return;
        case 1:
            m_newRandNum->setInterval(300);
            return;
        case 2:
            m_newRandNum->setInterval(200);
            return;
    }
}

// VisualizerWidget::s_randomizer()
//
// Creates a new random number from 1 to 100 using the C++ rand() function.
// It will only insert the random value into the list's index if it is larger.
//
void VisualizerWidget::s_randomizer(){
    //Generates 10 random numbers from 1 to 100 and places them in an array
    for(int i = 0; i < 10; i++){
        float random = rand() % 100 + 1;

        //Only insert random numbers larger than the current number
        if(numArray[i] < random)
            numArray[i] = random;
    }

}

// VisualizerWidget::paintGL()
//
// Creates 10 bars with heights from the random values generated by s_randomizer()
// Also decrements each of the random values by 0.5 to achieve a "falling effect"
//
void VisualizerWidget::paintGL(){
    //Clear the buffers to the default values and set the current matrix to the identity matrix
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    //Paint each of the ten bars
    for(int i = 0; i < 10; i++){
        float barval = numArray[i]/100;

        //Move each bar over by 1.1 to leave a small gap inbetween them.
        glTranslatef(1.1,0,0);

        //Begin painting the bar
        glPushMatrix();
        glBegin(GL_QUADS);

        //Sets the bottom two vertices of the bar to a color from blue to red
        //depending on the value of i
        glColor3f((float)i/9,0,(1 - (float)i/9));
        glVertex3f(-0.5,0,0);
        glVertex3f(0.5,0,0);

        //Sets the top two vertices of the bar to a color from red to blue
        //depending on the value of i
        glColor3f((1-(float)i/9),0,(float)i/9);
        glVertex3f(0.5,barval,0);
        glVertex3f(-0.5,barval,0);
        glEnd();

        //Create a white outline around each bar
        glColor3f(1, 1, 1);
        glLineWidth(2);
        glBegin(GL_LINE_LOOP);
        glVertex3f(-0.5, 0, 0);
        glVertex3f(0.5, 0, 0);
        glVertex3f(0.5, barval, 0);
        glVertex3f(-0.5, barval, 0);
        glEnd();
        glPopMatrix();

        //Decrement the current value in the array by .5 in order to make the bar "fall down"
        //If numArray[i] <= 0, it won't decrement it (in case the program runs long enough to cause an overflow, as unlikely as that is)
        if(numArray[i] > 0)
            numArray[i] = numArray[i] - .5;
        else
            numArray[i] = 0;
    }
    glFlush();
}
